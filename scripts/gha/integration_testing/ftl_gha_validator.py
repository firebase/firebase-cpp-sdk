#!/usr/bin/env python

# Copyright 2022 Google
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import logging
import subprocess
import shutil
import re

GSUTIL = shutil.which("gsutil")

def validate(test_summary):
  if not test_summary:
    logging.error("Nothing to be validate! Please provide test_summary")
    return False

  app_path = test_summary.get("testapp_path")
  return_code = test_summary.get("return_code")
  logging.info("testapp: %s\nreturn code: %s" % (app_path, return_code))
  if return_code == 0:
    gcs_dir = test_summary.get("raw_result_link").replace("https://console.developers.google.com/storage/browser/", "gs://")
    logging.info("gcs_dir: %s" % gcs_dir)
    logs = _get_testapp_log_text_from_gcs(gcs_dir)
    logging.info("Test result: %s", logs)
    return _validate_logs(logs)
  else:
    logging.error("Test failed: %s", app_path)
    return False


def _get_testapp_log_text_from_gcs(gcs_path):
  """Gets the testapp log text generated by game loops."""
  try:
    gcs_contents = _gcs_list_dir(gcs_path)
  except subprocess.CalledProcessError as e:
    logging.error("Unexpected error searching GCS logs:\n%s", e)
    return None
  # The path to the testapp log depends on the platform, device, and scenario
  # being tested. Search for a json file with 'results' in the name to avoid
  # hard-coding too many assumptions about the path. The testapp log should be
  # the only json, but 'results' adds some redundancy in case this changes.
  matching_gcs_logs = [
    line for line in gcs_contents
    if line.endswith(".json") and "results" in line.lower()
  ]
  if not matching_gcs_logs:
    logging.error("Failed to find results log on GCS.")
    return None
  # This assumes testapps only have one scenario. Could change in the future.
  if len(matching_gcs_logs) > 1:
    logging.warning("Multiple scenario logs found.")
  gcs_log = matching_gcs_logs[0]
  try:
    logging.info("Found results log: %s", gcs_log)
    log_text = _gcs_read_file(gcs_log)
    if not log_text:
      logging.warning("Testapp log is empty. App may have crashed.")
    return log_text
  except subprocess.CalledProcessError as e:
    logging.error("Unexpected error reading GCS log:\n%s", e)
    return None


def _gcs_list_dir(gcs_path):
  """Recursively returns a list of contents for a directory on GCS."""
  args = [GSUTIL, "ls", "-r", gcs_path]
  logging.info("Listing GCS contents: %s", " ".join(args))
  result = subprocess.run(args=args, capture_output=True, text=True, check=True)
  return result.stdout.splitlines()


def _gcs_read_file(gcs_path):
  """Extracts the contents of a file on GCS."""
  args = [GSUTIL, "cat", gcs_path]
  logging.info("Reading GCS file: %s", " ".join(args))
  result = subprocess.run(args=args, capture_output=True, text=True, check=True)
  return result.stdout


def _validate_logs(log_text):
  if not log_text:
    return False
 
  # The gtest runner dumps a useful summary of tests after the tear down.
  end_marker = "Global test environment tear-down"
  complete = end_marker in log_text

  if complete:
    # rpartition splits a string into three components around the final
    # occurrence of the end marker, returning a triplet (before, marker, after)
    result_summary = log_text.rpartition(end_marker)[2].lstrip()
    failures = re.search(r"\[  FAILED  \] (?P<count>[0-9]+) test", result_summary)
    logging.info("_validate_logs failures: %s", failures)
    if failures:
      return False
    else:
      return True
  else:
    return False
